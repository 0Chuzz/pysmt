diff -rupN pycudd2.0.2/cudd-2.4.2/Makefile_64bit pycudd2.0.2.patched/cudd-2.4.2/Makefile_64bit
--- pycudd2.0.2/cudd-2.4.2/Makefile_64bit	1970-01-01 01:00:00.000000000 +0100
+++ pycudd2.0.2.patched/cudd-2.4.2/Makefile_64bit	2015-02-26 15:21:40.906737759 +0100
@@ -0,0 +1,331 @@
+# $Id$
+#
+# Makefile for the CUDD distribution kit
+#---------------------------------------------------------------------------
+
+# Beginning of the configuration section. These symbol definitions can
+# be overridden from the command line.
+
+# C++ compiler
+CPP	= g++
+#CPP	= icpc
+#CPP	= ecpc
+#CPP	= CC
+#CPP	= /usr/local/opt/SUNWspro/bin/CC
+#CPP	= cxx
+
+# Specific options for compilation of C++ files.
+CPPFLAGS =
+# Stricter standard conformance for g++.
+#CPPFLAGS = -std=c++98
+# For Sun CC version 5, this invokes compatibility mode.
+#CPPFLAGS = -compat
+# On some versions of UP-UX, it is necessary to pass the option +a1
+# to CC for the C++ test program to compile successfully.
+#CPPFLAGS = +a1
+
+# C compiler used for all targets except optimize_dec, which always uses cc.
+#CC	= cc
+#CC	= /usr/local/opt/SUNWspro/bin/cc
+CC	= gcc
+#CC	= icc
+#CC	= ecc
+#CC	= /usr/ucb/cc
+#CC	= c89
+#CC	= $(CPP)
+
+# On some machines ranlib is either non-existent or redundant.
+# Use the following definition if your machine has ranlib and you think
+# it is needed.
+RANLIB	= ranlib
+# Use the following definition if your machine either does not have
+# ranlib (e.g., SUN running solaris) or can do without it (e.g., DEC Alpha).
+#RANLIB	= :
+
+# Use ICFLAGS to specify machine-independent compilation flags.
+# These three are typical settings for cc.
+#ICFLAGS	= -g
+#ICFLAGS	= -O
+#ICFLAGS	=
+# These four are typical settings for optimized code with gcc.  The
+# last two also work with icc/ecc.
+#ICFLAGS	= -g -O6 -Wall
+ICFLAGS	= -g -O6
+#ICFLAGS	= -g -O3 -Wall
+#ICFLAGS	= -g -O3
+
+# Use XCFLAGS to specify machine-dependent compilation flags.
+# For some platforms no special flags are needed.
+#XCFLAGS	= -DHAVE_IEEE_754 -DBSD
+#
+#==========================
+#  Linux
+#
+# Gcc 3.2.2 or higher on i686.
+#XCFLAGS	= -mtune=pentium4 -malign-double -DHAVE_IEEE_754 -DBSD
+# Gcc 2.8.1 on i686.
+#XCFLAGS	= -mcpu=pentiumpro -malign-double -DHAVE_IEEE_754 -DBSD
+# Gcc 4.2.4 or higher on x86 (32-bit)
+#XCFLAGS	= -m32 -DHAVE_IEEE_754 -DBSD -DSIZEOF_VOID_P=4 -DSIZEOF_LONG=8 -fPIC
+# Gcc 4.2.4 or higher on x86_64 (64-bit compilation)
+XCFLAGS	= -mtune=native -DHAVE_IEEE_754 -DBSD -DSIZEOF_VOID_P=8 -DSIZEOF_LONG=8 -fPIC
+# Gcc 4.2.4 or higher on x86_64 (32-bit compilation)
+#XCFLAGS	= -m32 -mtune=native -malign-double -DHAVE_IEEE_754 -DBSD
+# Icc on i686 (older versions may not support -xHost).
+#XCFLAGS	= -ansi -xHost -align -ip -DHAVE_IEEE_754 -DBSD
+# Icc on x86_64 (64-bit compilation).
+#XCFLAGS	= -ansi -xHost -align -ip -DHAVE_IEEE_754 -DBSD -DSIZEOF_VOID_P=8 -DSIZEOF_LONG=8
+# Gcc on ia64.
+#XCFLAGS	= -DHAVE_IEEE_754 -DBSD -DSIZEOF_VOID_P=8 -DSIZEOF_LONG=8
+# Icc/ecc on ia64.
+#XCFLAGS = -ansi -DBSD -DHAVE_IEEE_754 -DSIZEOF_VOID_P=8 -DSIZEOF_LONG=8
+#
+#==========================
+#  Solaris
+#
+# For Solaris, BSD should not be replaced by UNIX100.
+#XCFLAGS	= -DHAVE_IEEE_754 -DUNIX100 -DEPD_BIG_ENDIAN
+# Gcc 2.8.1 or higher on Ultrasparc.
+#XCFLAGS	= -mcpu=ultrasparc -DHAVE_IEEE_754 -DUNIX100 -DEPD_BIG_ENDIAN
+# For Solaris 2.5 and higher, optimized code with /usr/bin/cc or CC.
+#XCFLAGS	= -DHAVE_IEEE_754 -DUNIX100 -xO5 -native -dalign -DEPD_BIG_ENDIAN
+# On IA platforms, -dalign is not supported and causes warnings.
+#XCFLAGS	= -DHAVE_IEEE_754 -DUNIX100 -xO5 -native
+# Recent Sun compilers won't let you use -native on old Ultras.
+#XCFLAGS	= -DHAVE_IEEE_754 -DUNIX100 -xO5 -dalign -xlibmil -DEPD_BIG_ENDIAN
+# For Solaris 2.4, optimized code with /usr/bin/cc.
+#XCFLAGS	= -DHAVE_IEEE_754 -DUNIX100 -xO4 -dalign -DEPD_BIG_ENDIAN
+# For Solaris 2.5 and higher, optimized code with /usr/ucb/cc.
+#XCFLAGS	= -DHAVE_IEEE_754 -DBSD -xO5 -native -dalign -DEPD_BIG_ENDIAN
+#XCFLAGS	= -DHAVE_IEEE_754 -DBSD -xO5 -dalign -xlibmil -DEPD_BIG_ENDIAN
+# For Solaris 2.4, optimized code with /usr/ucb/cc.
+#XCFLAGS	= -DHAVE_IEEE_754 -DBSD -xO4 -dalign -DEPD_BIG_ENDIAN
+#
+#==========================
+#  DEC Alphas running Digital Unix
+#
+# For DEC Alphas either -ieee_with_inexact or -ieee_with_no_inexact is
+# needed. If you use only BDDs, -ieee_with_no_inexact is enough.
+# In the following, we consider three different compilers:
+# - the old native compiler (the one of MIPS ancestry that produces u-code);
+# - the new native compiler;
+# - gcc
+# On the Alphas, gcc (as of release 2.7.2) does not support 32-bit pointers
+# and IEEE 754 floating point arithmetic. Therefore, for this architecture
+# only, the native compilers provide a substatial advantage.
+# With the native compilers, specify -xtaso for 32-bit pointers.
+# Do not use -xtaso_short because explicit reference to stdout and stderr
+# does not work with this option. (Among other things.)
+# Notice that -taso must be included in LDFLAGS for -xtaso to work.
+# Given the number of possible choices, only some typical configurations
+# are proposed here.
+#
+# Old native compiler for the Alphas; 64-bit pointers.
+#XCFLAGS	= -DBSD -DHAVE_IEEE_754 -ieee_with_no_inexact -tune host -DSIZEOF_VOID_P=8 -DSIZEOF_LONG=8
+# Old native compiler for the Alphas; 32-bit pointers.
+#XCFLAGS	= -DBSD -DHAVE_IEEE_754 -ieee_with_no_inexact -tune host -xtaso -DSIZEOF_LONG=8
+# New native compiler for the Alphas; 64-bit pointers.
+#XCFLAGS	= -g3 -O4 -std -DBSD -DHAVE_IEEE_754 -ieee_with_no_inexact -tune host -DSIZEOF_VOID_P=8 -DSIZEOF_LONG=8
+# New native compiler for the Alphas; 32-bit pointers.
+#XCFLAGS	= -g3 -O4 -std -DBSD -DHAVE_IEEE_754 -ieee_with_no_inexact -tune host -xtaso -DSIZEOF_LONG=8
+# gcc for the Alphas: compile without HAVE_IEEE_754.
+#XCFLAGS	= -DBSD -DSIZEOF_VOID_P=8 -DSIZEOF_LONG=8
+#
+#==========================
+#
+#  IBM RS6000
+#
+# For the IBM RS6000 -qstrict is necessary when specifying -O3 with cc.
+#XCFLAGS	= -DBSD -DHAVE_IEEE_754 -DEPD_BIG_ENDIAN -O3 -qstrict
+#
+#==========================
+#
+#  HP-UX
+#
+# I haven't figured out how to enable IEEE 754 on the HPs I've tried...
+# For HP-UX using gcc.
+#XCFLAGS	= -DUNIX100 -DEPD_BIG_ENDIAN
+# For HP-UX using c89.
+#XCFLAGS	= +O3 -DUNIX100 -DEPD_BIG_ENDIAN
+#
+#==========================
+#
+#  Windows 95/98/NT/XP/Vista with Cygwin tools
+#
+# The value of RLIMIT_DATA_DEFAULT should reflect the amount of
+# available memory (expressed in bytes).
+# Recent versions of cygwin have getrlimit, but the datasize limit
+# cannot be set.
+#XCFLAGS	= -mtune=pentium4 -malign-double -DHAVE_IEEE_754 -DHAVE_GETRLIMIT=0 -DRLIMIT_DATA_DEFAULT=268435456
+
+
+# Define the level of self-checking and verbosity of the CUDD package.
+#DDDEBUG = -DDD_DEBUG -DDD_VERBOSE -DDD_STATS -DDD_CACHE_PROFILE -DDD_UNIQUE_PROFILE -DDD_COUNT
+DDDEBUG	=
+
+# Define the level of self-checking and verbosity of the MTR package.
+#MTRDEBUG = -DMTR_DEBUG
+MTRDEBUG =
+
+# Loader options.
+LDFLAGS	=
+# This may produce faster code on the DECstations.
+#LDFLAGS	= -jmpopt -Olimit 1000
+# This may be necessary under some old versions of Linux.
+#LDFLAGS	= -static
+# This normally makes the program faster on the DEC Alphas.
+#LDFLAGS	= -non_shared -om
+# This is for 32-bit pointers on the DEC Alphas.
+#LDFLAGS	= -non_shared -om -taso
+#LDFLAGS	= -non_shared -taso
+
+# Define PURE as purify to link with purify.
+# Define PURE as quantify to link with quantify.
+# Remember to compile with -g if you want line-by-line info with quantify.
+PURE =
+#PURE	= purify
+#PURE	= quantify
+
+# Define EXE as .exe for MS-DOS and derivatives.  Not required by recent
+# versions of cygwin.
+EXE	=
+#EXE	= .exe
+
+# End of the configuration section.
+#---------------------------------------------------------------------------
+
+MFLAG   = -DMNEMOSYNE
+MNEMLIB	= ../mnemosyne/libmnem.a
+
+DDWDIR	= .
+IDIR	= $(DDWDIR)/include
+INCLUDE = -I$(IDIR)
+
+BDIRS	= cudd dddmp mtr st util epd
+DIRS	= $(BDIRS) nanotrav
+
+#------------------------------------------------------------------------
+
+.PHONY : build
+.PHONY : nanotrav
+.PHONY : check_leaks
+.PHONY : optimize_dec
+.PHONY : testcudd
+.PHONY : libobj
+.PHONY : testobj
+.PHONY : testdddmp
+.PHONY : testmtr
+.PHONY : lint
+.PHONY : all
+.PHONY : clean
+.PHONY : distclean
+
+
+build:
+	sh ./setup.sh
+	@for dir in $(DIRS); do \
+		(cd $$dir; \
+		echo Making $$dir ...; \
+		make CC=$(CC) RANLIB=$(RANLIB) MFLAG= MNEMLIB= ICFLAGS="$(ICFLAGS)" XCFLAGS="$(XCFLAGS)" DDDEBUG="$(DDDEBUG)" MTRDEBUG="$(MTRDEBUG)" LDFLAGS="$(LDFLAGS)" PURE="$(PURE)" EXE="$(EXE)" )\
+	done
+
+libso:
+	@for dir in $(DIRS); do\
+		(cd $$dir;\
+		echo Making $$ dir;\
+		make libso CC=$(CC) RANLIB=$(RANLIB) MFLAG= MNEMLIB= ICFLAGS="$(ICFLAGS)" XCFLAGS="$(XCFLAGS)" DDDEBUG="$(DDDEBUG)" MTRDEBUG="$(MTRDEBUG)" LDFLAGS="$(LDFLAGS)" PURE="$(PURE)" EXE="$(EXE)" )\
+	done
+
+nanotrav: build
+
+check_leaks:
+	sh ./setup.sh
+	@for dir in mnemosyne $(DIRS); do \
+		(cd $$dir; \
+		echo Making $$dir ...; \
+		make CC=$(CC) RANLIB=$(RANLIB) MFLAG=$(MFLAG) MNEMLIB=$(MNEMLIB) ICFLAGS="$(ICFLAGS)" XCFLAGS="$(XCFLAGS)" DDDEBUG="$(DDDEBUG)" MTRDEBUG="$(MTRDEBUG)" LDFLAGS="$(LDFLAGS)" EXE="$(EXE)" )\
+	done
+
+optimize_dec:
+	sh ./setup.sh
+	@for dir in $(DIRS); do \
+		(cd $$dir; \
+		echo Making $$dir ...; \
+		make CC=$(CC) RANLIB=$(RANLIB) XCFLAGS="$(XCFLAGS)" LDFLAGS="$(LDFLAGS)" optimize_dec )\
+	done
+
+lint:
+	sh ./setup.sh
+	@for dir in $(DIRS) obj; do \
+		(cd $$dir; \
+		echo Making lint in $$dir ...; \
+		make CC=$(CC) lint )\
+	done
+
+tags:
+	sh ./setup.sh
+	@for dir in $(DIRS) obj; do \
+		(cd $$dir; \
+		echo Making tags in $$dir ...; \
+		make CC=$(CC) tags )\
+	done
+
+all:
+	sh ./setup.sh
+	@for dir in $(DIRS); do \
+		(cd $$dir; \
+		echo Making all in $$dir ...; \
+		make CC=$(CC) RANLIB=$(RANLIB) MFLAG= MNEMLIB= ICFLAGS="$(ICFLAGS)" XCFLAGS="$(XCFLAGS)" DDDEBUG="$(DDDEBUG)" MTRDEBUG="$(MTRDEBUG)" LDFLAGS="$(LDFLAGS)" PURE="$(PURE)" EXE="$(EXE)" all )\
+	done
+
+testcudd:
+	sh ./setup.sh
+	@for dir in util st mtr epd; do \
+		(cd $$dir; \
+		echo Making $$dir ...; \
+		make CC=$(CC) RANLIB=$(RANLIB) MFLAG= MNEMLIB= ICFLAGS="$(ICFLAGS)" XCFLAGS="$(XCFLAGS)" DDDEBUG="$(DDDEBUG)" MTRDEBUG="$(MTRDEBUG)" LDFLAGS="$(LDFLAGS)" PURE="$(PURE)" EXE="$(EXE)" )\
+	done
+	@(cd cudd; \
+	echo Making testcudd ...; \
+	make CC=$(CC) RANLIB=$(RANLIB) MFLAG= MNEMLIB= ICFLAGS="$(ICFLAGS)" XCFLAGS="$(XCFLAGS)" DDDEBUG="$(DDDEBUG)" MTRDEBUG="$(MTRDEBUG)" LDFLAGS="$(LDFLAGS)" PURE="$(PURE)" EXE="$(EXE)" testcudd$(EXE) )
+
+objlib:
+	sh ./setup.sh
+	@for dir in $(BDIRS); do \
+		(cd $$dir; \
+		echo Making $$dir ...; \
+		make CC=$(CC) RANLIB=$(RANLIB) MFLAG= MNEMLIB= ICFLAGS="$(ICFLAGS)" XCFLAGS="$(XCFLAGS)" DDDEBUG="$(DDDEBUG)" MTRDEBUG="$(MTRDEBUG)" LDFLAGS="$(LDFLAGS)" PURE="$(PURE)" EXE="$(EXE)" )\
+	done
+	@(cd obj; \
+	echo Making obj ...; \
+	make CPP=$(CPP) CPPFLAGS=$(CPPFLAGS) RANLIB=$(RANLIB) MFLAG= MNEMLIB= ICFLAGS="$(ICFLAGS)" XCFLAGS="$(XCFLAGS)" DDDEBUG="$(DDDEBUG)" MTRDEBUG="$(MTRDEBUG)" LDFLAGS="$(LDFLAGS)" PURE="$(PURE)" EXE="$(EXE)" )
+
+testobj: objlib
+	@(cd obj; \
+	echo Making testobj ...; \
+	make CPP=$(CPP) CPPFLAGS=$(CPPFLAGS) RANLIB=$(RANLIB) MFLAG= MNEMLIB= ICFLAGS="$(ICFLAGS)" XCFLAGS="$(XCFLAGS)" DDDEBUG="$(DDDEBUG)" MTRDEBUG="$(MTRDEBUG)" LDFLAGS="$(LDFLAGS)" PURE="$(PURE)" EXE="$(EXE)" testobj$(EXE) )
+
+testdddmp: build
+	@(cd dddmp; \
+	echo Making testdddmp ...; \
+	make CC=$(CC) RANLIB=$(RANLIB) MFLAG= MNEMLIB= ICFLAGS="$(ICFLAGS)" XCFLAGS="$(XCFLAGS)" DDDEBUG="$(DDDEBUG)" MTRDEBUG="$(MTRDEBUG)" LDFLAGS="$(LDFLAGS)" PURE="$(PURE)" EXE="$(EXE)" testdddmp$(EXE) )
+
+testmtr: build
+	@(cd mtr; \
+	echo Making testmtr ...; \
+	make CC=$(CC) RANLIB=$(RANLIB) MFLAG= MNEMLIB= ICFLAGS="$(ICFLAGS)" XCFLAGS="$(XCFLAGS)" DDDEBUG="$(DDDEBUG)" MTRDEBUG="$(MTRDEBUG)" LDFLAGS="$(LDFLAGS)" PURE="$(PURE)" EXE="$(EXE)" testmtr$(EXE) )
+
+clean:
+	@for dir in mnemosyne $(DIRS) obj; do	\
+	    (cd $$dir;	\
+	     echo Cleaning $$dir ...; \
+	     make -s clean	) \
+	done
+
+distclean:
+	@for dir in mnemosyne $(DIRS) obj; do	\
+	    (cd $$dir;	\
+	     echo Cleaning $$dir ...; \
+	     make -s EXE="$(EXE)" distclean	) \
+	done
+	sh ./shutdown.sh
diff -rupN pycudd2.0.2/pycudd/ddmanager.i pycudd2.0.2.patched/pycudd/ddmanager.i
--- pycudd2.0.2/pycudd/ddmanager.i	2012-03-30 22:47:57.000000000 +0200
+++ pycudd2.0.2.patched/pycudd/ddmanager.i	2015-02-26 15:21:40.914737759 +0100
@@ -157,7 +157,9 @@ struct DdManager { };
 #endif
     int retval = Cudd_CheckZeroRef(self);
     if (!retval) {
+#ifdef PYCUDD_DEBUG
       cerr << "Quitting manager" << endl;
+#endif
     } else {
 #ifdef PYCUDD_DEBUG
       cerr << retval << " unexpected non-zero reference counts" << endl;
@@ -170,12 +172,21 @@ struct DdManager { };
     mgr = NULL;
   }
 
+  bool __eq__(DdManager* other) {
+    return self == other ? TRUE : FALSE;
+  }
+
+  bool __neq__(DdManager* other) {
+    return self != other ? TRUE : FALSE;
+  }
+
+
   // This takes a long int representing the address of a DdNode and 
   // derefs it. Use with caution!!
   void KillNode(long int num) {
 #ifdef PYCUDD_DEBUG
     cerr << "Derefing " << hex << num << endl;
-#endif PYCUDD_DEBUG
+#endif /* PYCUDD_DEBUG */
     Cudd_RecursiveDeref(self, (DdNode *) num);
   }
 
@@ -492,4 +503,5 @@ struct DdManager { };
   void SetDefault() {
     mgr = self;
   }
+
 };
diff -rupN pycudd2.0.2/pycudd/Makefile pycudd2.0.2.patched/pycudd/Makefile
--- pycudd2.0.2/pycudd/Makefile	2012-03-30 23:33:11.000000000 +0200
+++ pycudd2.0.2.patched/pycudd/Makefile	2015-02-26 15:21:40.914737759 +0100
@@ -17,7 +17,8 @@ MOD = pycudd
 ## Change these to reflect local settings
 ##
 #######
-CUDD        := ../cudd-2.4.2/
+TOP         := $(shell pwd)
+CUDD        := $(TOP)/../cudd-2.4.2/
 CUDDVER     = 0x020400
 PYTHON_LOC  := /usr
 # Change the following to lib64 for 64-bit architectures
@@ -39,7 +40,7 @@ PYCUDD_DEBUG =
 
 ##
 ## For internal use only
-TESTING = 
+TESTING =
 
 #######
 ##
@@ -64,16 +65,16 @@ SWIG_FLAGS  := -c++ -python -o $(MOD)_wr
 #FLAGS       := -malign-double -DCUDDVER=$(CUDDVER)
 #
 # For AMD64:
-# -malign-double is meaningless. 
+# -malign-double is meaningless.
 FLAGS       := -DCUDDVER=$(CUDDVER) -fPIC
 #
 ifdef PYCUDD_DEBUG
 FLAGS       := $(FLAGS) -g -DPYCUDD_DEBUG
 SWIG_FLAGS  := $(SWIG_FLAGS) -DPYCUDD_DEBUG -v -Wall
 else
-FLAGS       := $(FLAGS) -O2 
+FLAGS       := $(FLAGS) -O2
 endif
-LFLAGS      := -Xlinker -rpath $(CUDD)/lib 
+LFLAGS      := -Xlinker -rpath $(CUDD)/lib
 
 #######
 ##
@@ -86,7 +87,7 @@ BREL_INCL   := -I$(BREL_LOC) -I$(BREL_LO
 INCLUDES    := $(INCLUDES) $(BREL_INCL)
 DEP_INCL    := $(DEP_INCL) $(BREL_INCL)
 LDFLAGS     := $(LDFLAGS) -L$(BREL_LOC) -lbrel
-FLAGS       := $(FLAGS) -DBREL_R_THERE 
+FLAGS       := $(FLAGS) -DBREL_R_THERE
 LFLAGS      := $(LFLAGS) -Xlinker -rpath $(BREL_LOC)
 SWIG_FLAGS  := $(SWIG_FLAGS) -DBREL_R_THERE
 endif
@@ -128,11 +129,11 @@ $(MOD)_wrap.cpp:$(SWG)
 clean:
 	rm -f *.o *_wrap* *.pyc *.pyo _$(MOD).so $(MOD).py $(MOD)tmp.py docstring.h;
 
-depend: 
+depend:
 	@sed "/^# DO NOT CHANGE THIS OR ANY SUCCEEDING LINE -- AUTOGENERATED DEPS/, $$ d" Makefile > mktemp
 	@echo "# DO NOT CHANGE THIS OR ANY SUCCEEDING LINE -- AUTOGENERATED DEPS" >> mktemp
 	@$(CCPLUS) $(FLAGS) $(DEP_INCL) -E -MM $(MOD).cpp >> mktemp
-# The next line tries to get the C++ dependencies for the SWIG interface files 
+# The next line tries to get the C++ dependencies for the SWIG interface files
 # First sed prints out the raw C++ code between %{...%}. Second sed removes those markers and any #error directives. Finally, generate a rule for our wrapper cpp file
 	@sed -n "/^%{/,/%}/ p" $(SWG) | sed -e "s/^%[{}].*\|#error.*//" | $(CCPLUS) -x c++ $(FLAGS) $(DEP_INCL) -E -MM -MQ "$(MOD)_wrap.cpp" - >> mktemp
 	@mv -f mktemp Makefile
diff -rupN pycudd2.0.2/pycudd/pycudd.cpp pycudd2.0.2.patched/pycudd/pycudd.cpp
--- pycudd2.0.2/pycudd/pycudd.cpp	2012-03-30 22:47:57.000000000 +0200
+++ pycudd2.0.2.patched/pycudd/pycudd.cpp	2015-02-27 18:10:20.363051228 +0100
@@ -17,8 +17,8 @@ IntArray::IntArray(int size) {
   if (size < 0)
     sz = Cudd_ReadSize(mgr);
   else
-    sz = size; 
-  vec = new int[sz]; 
+    sz = size;
+  vec = new int[sz];
   memset( vec, 0, sz * sizeof(int));
 }
 
@@ -27,10 +27,10 @@ IntArray::~IntArray() {
 }
 
 void IntArray::AssignVect(int* cuddvec, int size) {
-   
-  sz = size; 
+
+  sz = size;
   delete [] vec;
-  vec = new int[sz]; 
+  vec = new int[sz];
   memcpy( vec, cuddvec, sz * sizeof(int));
 }
 
@@ -44,9 +44,9 @@ void IntArray::AssignComplVect(int* cudd
   temp[size] = univ;
   qsort( temp, size, sizeof(int), IntCompareFunc);
   int *iptr = temp;
-  sz = univ - size; 
+  sz = univ - size;
   delete [] vec;
-  vec = new int[sz]; 
+  vec = new int[sz];
   int *nptr = vec;
   for (int i=0; i < univ; i++) {
     if (i < *iptr) *nptr++ = i;
@@ -58,8 +58,8 @@ void IntArray::AssignComplVect(int* cudd
 }
 
 StringArray::StringArray(int size) {
-  sz = size; 
-  vec = new char *[sz]; 
+  sz = size;
+  vec = new char *[sz];
   memset( vec, 0, sz * sizeof(char *));
 }
 
@@ -76,17 +76,17 @@ DoubleArray::DoubleArray(int size) {
   if (size < 0)
     sz = Cudd_ReadSize(mgr);
   else
-    sz = size; 
-  vec = new double[sz]; 
-  for(int j=0; j<sz; j++) 
-    vec[j] = 0; 
+    sz = size;
+  vec = new double[sz];
+  for(int j=0; j<sz; j++)
+    vec[j] = 0;
 }
 
 DoubleArray::~DoubleArray() {
   delete [] vec;
 }
 
-DdArray::DdArray(int size) { 
+DdArray::DdArray(int size) {
 
 #ifdef PYCUDD_DEBUG
   cerr << endl << "Constructor for DdArray called" << endl;
@@ -94,54 +94,54 @@ DdArray::DdArray(int size) {
   if (size < 0)
     sz = Cudd_ReadSize(mgr);
   else
-    sz = size; 
-  i = 0; 
-  vec = new DdNode*[sz]; 
-  for(int j=0; j<sz; j++) 
-    vec[j] = NULL; 
+    sz = size;
+  i = 0;
+  vec = new DdNode*[sz];
+  for(int j=0; j<sz; j++)
+    vec[j] = NULL;
 }
 
-DdArray::~DdArray() {  
+DdArray::~DdArray() {
 
 #ifdef PYCUDD_DEBUG
   cerr << endl << "Deleting DdArray" << endl;
 #endif
   if (mgr) {
      for(int j=0; j<sz; j++) {
-       if(vec[j]!=NULL) 
-         Cudd_RecursiveDeref(mgr,vec[j]); 
+       if(vec[j]!=NULL)
+         Cudd_RecursiveDeref(mgr,vec[j]);
        vec[j] = NULL;
      }
-  } 
-  delete [] vec; 
+  }
+  delete [] vec;
 }
 
 DdNode*
 DdArray::Pop() {
   if (i!=0) {
-    DdNode* result=vec[--i]; 
-    vec[i]=NULL; 
-    if (result!=NULL) Cudd_RecursiveDeref(mgr,result); 
+    DdNode* result=vec[--i];
+    vec[i]=NULL;
+    if (result!=NULL) Cudd_RecursiveDeref(mgr,result);
     return result;
   }
   return NULL;
 }
 
 void
-DdArray::Push(DdNode* val) { 
-  if (i<sz) { 
+DdArray::Push(DdNode* val) {
+  if (i<sz) {
     if (vec[i]!=NULL) Cudd_RecursiveDeref(mgr,vec[i]);
-    vec[i++]=val; 
-    Cudd_Ref(val); 
-  } 
+    vec[i++]=val;
+    Cudd_Ref(val);
+  }
 }
 
-DdNode* 
-DdArray::And() { 
+DdNode*
+DdArray::And() {
   DdNode *result;
   DdNode *tmp;
   int i;
- 
+
   OrderVector(0, sz-1);
   result = vec[0];
   Cudd_Ref(result);
@@ -156,18 +156,18 @@ DdArray::And() {
 
   return result;
 }
-  
-DdNode* 
+
+DdNode*
 DdArray::Or() {
   DdNode *tmp;
   DdNode *result;
   int i;
- 
+
   OrderVector(0, sz-1);
   result = vec[0];
   Cudd_Ref(result);
 
-  for (i=1; i<sz; i++) { 
+  for (i=1; i<sz; i++) {
     tmp = Cudd_bddOr(mgr,vec[i],result);
     Cudd_Ref(tmp);
     Cudd_RecursiveDeref(mgr,result);
@@ -206,7 +206,7 @@ DdArray::AtLeastN(int n) {
     Cudd_RecursiveDeref(mgr,temp[0]);
     temp[0]= tmp;
 
-    for( j=1; j < max_width; j++) { 
+    for( j=1; j < max_width; j++) {
       tmp = Cudd_bddIte( mgr, vec[i+j], temp[j], temp[j-1]);
       Cudd_Ref(tmp);
       Cudd_RecursiveDeref(mgr,temp[j]);
@@ -256,7 +256,7 @@ DdArray::UpToN( int n ) {
       Cudd_RecursiveDeref(mgr,temp[j]);
       temp[j]= tmp;
     }
-     
+
   tmp = temp[0];
   for ( i=1; i<=max_width; i++)
     Cudd_RecursiveDeref(mgr, temp[i]);
@@ -271,7 +271,7 @@ DdArray::SwapNodes( int i, int j) {
   DdNode *tmp = vec[i];
   vec[i] = vec[j];
   vec[j] = tmp;
-}  
+}
 
 DdNode*
 DdArray::ExactlyN( int n ) {
@@ -360,7 +360,7 @@ DdArray::Constraint(int low, int high) {
 }
 
 DdNode*
-DdArray::Compose(DdNode* term) { 
+DdArray::Compose(DdNode* term) {
   if (sz != Cudd_ReadSize(mgr)) {
     cerr << "Can't compose without representative bdd for each index in the vector\n" << sz << "  " << Cudd_ReadSize(mgr);
     return term;
@@ -374,7 +374,7 @@ void
 DdArray::Fill(int offset, int mod) {
 
   int j=offset;
-  for (int i=0; i<sz; i++,j+=mod) 
+  for (int i=0; i<sz; i++,j+=mod)
       __setitem__(i,Cudd_bddIthVar(mgr,j));
 }
 
@@ -382,8 +382,8 @@ void
 DdArray::FillWithIntArray( IntArray *a) {
   delete [] vec;
   sz = a->__len__();
-  vec = new DdNode*[sz]; 
-  for(int j=0; j<sz; j++) 
+  vec = new DdNode*[sz];
+  for(int j=0; j<sz; j++)
     vec[j] = Cudd_bddIthVar(mgr,a->vec[j]);
 }
 
@@ -396,7 +396,7 @@ DdArray::OrderVector( int left, int righ
 
   if (left >= right) return;
   tmp=vec[left]; vec[left]=vec[(left+right)/2]; vec[(left+right)/2]=tmp;
- 
+
   last = left;
 
   for (i=left+1; i<=right; i++)
@@ -416,7 +416,7 @@ DdArray::SupportVector( DdNode* term ) {
   Cudd_Ref(support);
   sz = Cudd_DagSize(support)-1;
   delete [] vec;
-  vec = new DdNode*[sz]; 
+  vec = new DdNode*[sz];
   memset( vec, 0, sz * sizeof(DdNode*));
   int vectindex = 0;
   while ((support != Cudd_Regular(Cudd_ReadOne(mgr))) && (support != Cudd_Regular(Cudd_ReadZero(mgr)))) {
@@ -439,9 +439,9 @@ DdArray::SetVarMap( DdArray* other ) {
 
 DdNode*
 DdArray::VectorSupport() {
-  DdNode* result = Cudd_VectorSupport(mgr,vec,sz); 
-  Cudd_Ref(result); 
-  return result; 
+  DdNode* result = Cudd_VectorSupport(mgr,vec,sz);
+  Cudd_Ref(result);
+  return result;
 }
 
 int
@@ -459,19 +459,19 @@ DdArray::PickOneMinterm( DdNode* term )
   return result;
 }
 
-DdNode* 
+DdNode*
 DdArray::HoldTR( DdArray* other ) {
   DdNode *tmp1,*tmp2;
   DdNode *result;
   int i;
- 
+
   result = Cudd_bddXnor(mgr,vec[0],other->vec[0]);
   Cudd_Ref(result);
 
-  for (i=1; i<sz; i++) { 
+  for (i=1; i<sz; i++) {
     tmp1 = Cudd_bddXnor(mgr,vec[i],other->vec[i]);
     Cudd_Ref(tmp1);
- 
+
     tmp2 = Cudd_bddAnd(mgr,result,tmp1);
     Cudd_Ref(tmp2);
     Cudd_RecursiveDeref(mgr,result);
@@ -531,13 +531,13 @@ DdArray::Load( char* filename ) {
 				     DDDMP_VAR_MATCHIDS,
 				     NULL,
 				     NULL,
-				     NULL, 
+				     NULL,
 				     DDDMP_MODE_BINARY,
 				     filename,
 				     NULL,
 				     &vec);
   sz = roots;
-  DdNode **p = new DdNode*[ sz];  
+  DdNode **p = new DdNode*[ sz];
   memcpy( p, vec, sz * sizeof( DdArray *));
   delete [] vec;
   vec = p;
@@ -550,7 +550,7 @@ DdArray::LoadText( char* filename ) {
 
   if (sz != 0)
     return -1;
-  
+
   delete [] vec;
 
   int roots = Dddmp_cuddBddArrayLoad(mgr,
@@ -559,7 +559,7 @@ DdArray::LoadText( char* filename ) {
 				     DDDMP_VAR_MATCHIDS,
 				     NULL,
 				     NULL,
-				     NULL, 
+				     NULL,
 				     DDDMP_MODE_TEXT,
 				     filename,
 				     NULL,
@@ -572,28 +572,40 @@ DdArray::LoadText( char* filename ) {
 
 }
 
-int 
-DdArray::ArrayLoad( int rootmatchmode, StringArray *rootmatchnames, int varmatchmode, 
-	       StringArray *varmatchnames, IntArray *varmatchauxids, 
-	       IntArray *varcomposeids, int mode, char *filename, FILE *fp) 
-{ 
-  int roots = Dddmp_cuddBddArrayLoad( mgr, (Dddmp_RootMatchType) rootmatchmode, 
-				 (char **) ( rootmatchnames ? rootmatchnames->vec : NULL), 
-				 (Dddmp_VarMatchType) varmatchmode, 
-				 (char **) ( varmatchnames ? varmatchnames->vec : NULL), 
-				 (int *) ( varmatchauxids ? varmatchauxids->vec : NULL), 
-				 (int *) ( varcomposeids ? varcomposeids->vec : NULL), 
-				 mode, filename, fp, &vec); 
+int
+DdArray::ArrayLoad( int rootmatchmode, StringArray *rootmatchnames, int varmatchmode,
+	       StringArray *varmatchnames, IntArray *varmatchauxids,
+	       IntArray *varcomposeids, int mode, char *filename, FILE *fp)
+{
+  int roots = Dddmp_cuddBddArrayLoad( mgr, (Dddmp_RootMatchType) rootmatchmode,
+				 (char **) ( rootmatchnames ? rootmatchnames->vec : NULL),
+				 (Dddmp_VarMatchType) varmatchmode,
+				 (char **) ( varmatchnames ? varmatchnames->vec : NULL),
+				 (int *) ( varmatchauxids ? varmatchauxids->vec : NULL),
+				 (int *) ( varcomposeids ? varcomposeids->vec : NULL),
+				 mode, filename, fp, &vec);
   return roots;
 }
-int 
-DdArray::ArrayStore( char *ddname, StringArray *rootnames, StringArray *varnames, IntArray *auxids, 
-		     int mode, int varinfo, char *filename, FILE *fp) 
-{ 
-  int roots =  Dddmp_cuddBddArrayStore( mgr, ddname, sz, vec, 
-				  (char **) ( rootnames ? rootnames->vec : NULL), 
-				  (char **) ( varnames ? varnames->vec : NULL), 
-				  (int *) ( auxids ? auxids->vec : NULL), mode, 
-				  (Dddmp_VarInfoType) varinfo, filename, fp); 
+int
+DdArray::ArrayStore( char *ddname, StringArray *rootnames, StringArray *varnames, IntArray *auxids,
+		     int mode, int varinfo, char *filename, FILE *fp)
+{
+  int roots =  Dddmp_cuddBddArrayStore( mgr, ddname, sz, vec,
+				  (char **) ( rootnames ? rootnames->vec : NULL),
+				  (char **) ( varnames ? varnames->vec : NULL),
+				  (int *) ( auxids ? auxids->vec : NULL), mode,
+				  (Dddmp_VarInfoType) varinfo, filename, fp);
   return roots;
 }
+
+DdManager* GetDefaultDdManager()
+{
+  if (mgr) return mgr;
+  else return NULL;
+}
+
+
+void ResetDefaultDdManager()
+{
+  mgr = NULL;
+}
diff -rupN pycudd2.0.2/pycudd/pycudd.h pycudd2.0.2.patched/pycudd/pycudd.h
--- pycudd2.0.2/pycudd/pycudd.h	2012-03-30 22:47:57.000000000 +0200
+++ pycudd2.0.2.patched/pycudd/pycudd.h	2015-02-27 18:10:01.795050638 +0100
@@ -11,6 +11,11 @@ extern DdManager* mgr;
 %feature("autodoc","1");
 #endif
 
+DdManager* GetDefaultDdManager();
+
+void ResetDefaultDdManager();
+
+
 // Exception class
 class RangeError {};
 
@@ -22,7 +27,7 @@ class IntArray {
 
  public:
   int* vec;
-  IntArray(int size);  
+  IntArray(int size);
   ~IntArray();
   void AssignVect( int *str, int size);
   void AssignComplVect( int *str, int size, int univ);
@@ -39,13 +44,13 @@ class IntArray {
   }
 }
 #endif
-  int __getitem__(int j) { 
+  int __getitem__(int j) {
     if (j<sz && j>=0) return vec[j];
-    throw RangeError(); 
+    throw RangeError();
   };
-  void __setitem__(int j, int val) { 
+  void __setitem__(int j, int val) {
     if (j<sz && j>=0) vec[j]=val;
-    else throw RangeError(); 
+    else throw RangeError();
   };
   int __len__() { return sz; }
   void Assign( int *list, int k) {
@@ -71,7 +76,7 @@ class StringArray {
 
  public:
   char** vec;
-  StringArray(int size);  
+  StringArray(int size);
   ~StringArray();
   char ***ArrayAddress() { return &vec; }
 
@@ -87,13 +92,13 @@ class StringArray {
 }
 #endif
 
-  char * __getitem__(int j) { 
-    if (j<sz && j>=0) return vec[j]; 
-    throw RangeError(); 
+  char * __getitem__(int j) {
+    if (j<sz && j>=0) return vec[j];
+    throw RangeError();
   };
   void __setitem__(int j, char *val) {
     if (j<sz && j>=0) vec[j]=val;
-    else throw RangeError(); 
+    else throw RangeError();
   };
   int __len__() { return sz; }
   void Assign( char **list, int k) {
@@ -135,13 +140,13 @@ class DoubleArray {
 }
 #endif
 
-  double __getitem__(int j) { 
-    if (j<sz && j>=0) return vec[j]; 
-    throw RangeError(); 
+  double __getitem__(int j) {
+    if (j<sz && j>=0) return vec[j];
+    throw RangeError();
   };
-  void __setitem__(int j, double  val) { 
+  void __setitem__(int j, double  val) {
     if (j<sz && j>=0) vec[j]=val;
-    else throw RangeError(); 
+    else throw RangeError();
   };
   void Assign( double *list, int k) {
     if (k > sz) throw RangeError();
@@ -191,15 +196,15 @@ public:
 
   DdNode* __getitem__(int j) {
     DdNode* result = NULL;
-    if (j<sz && j>=0) { 
+    if (j<sz && j>=0) {
       result = vec[j];
       Cudd_Ref(result);
     }
     else throw RangeError();
     return result;
   };
-  void __setitem__(int j, DdNode* val) { 
-    if (j<sz && j>=0) { 
+  void __setitem__(int j, DdNode* val) {
+    if (j<sz && j>=0) {
       if (vec[j]!=NULL) Cudd_RecursiveDeref(mgr,vec[j]);
       vec[j]=val;
       Cudd_Ref(vec[j]);
@@ -242,17 +247,17 @@ public:
   DdNode* VectorSupport();
   int VectorSupportIndex(int **dum_sup);
   DdNode* PickOneMinterm( DdNode* term );
-  DdNode* HoldTR( DdArray* other );  
+  DdNode* HoldTR( DdArray* other );
   int Find( DdNode* term);
   int Save( char* filename );
   int SaveText( char* filename );
   int Load( char* filename );
   int LoadText( char* filename );
-  int ArrayLoad( int rootmatchmode, StringArray *rootmatchnames, int varmatchmode, 
-		 StringArray *varmatchnames, IntArray *varmatchauxids, IntArray *varcomposeids, 
+  int ArrayLoad( int rootmatchmode, StringArray *rootmatchnames, int varmatchmode,
+		 StringArray *varmatchnames, IntArray *varmatchauxids, IntArray *varcomposeids,
 		 int mode, char *filename, FILE *fp=NULL);
-  int ArrayStore( char *ddname, StringArray *rootnames, StringArray *varnames, IntArray *auxids, 
+  int ArrayStore( char *ddname, StringArray *rootnames, StringArray *varnames, IntArray *auxids,
 		  int mode, int varinfo, char *filename, FILE *fp=NULL);
 };
-  
+
 #endif // PYCUDD_H
