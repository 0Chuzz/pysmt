How to add a new Theory within pySMT
====================================

In pySMT we are trying to closely follow the SMT-LIB standard. If the
theory you want to add is already part of the standard, than many
points below should be easy to answer.

1. Identify the set of operators that need to be added

You need to distinguish between operators that are needed to represent
the theory, and operators that are syntactic sugar. For example, in
pySMT we have less-than and less-than-equal, as basic operators, and
define greater-than and greater-than-equal as syntactic sugar.

2. Identify which solvers support the theory

For each solver that supports the theory, it is important to identify
which sub/super-set of the operators are supported and whether the
solver is already integrated in pySMT. The goal of this activity is to
identify possible incompatibilities in the way different solvers deal
with the theory.

3. Identify examples in "SMT-LIB" format

This provides a simple way of looking at how the theory is used, and
access to cheap tests.


Once these points are clear, please open an issue on github with the
answer to these points and a bit of motivation for the theory. In this
way we can discuss possible changes and ideas before you start working
on the code.


Code for a new Theory
---------------------

A good example of theory extension is represented by the BitVector
theory. In case of doubt, look at how the BitVector case (bv) has been
handled.

Adding a Theory to the codebase is done by following these steps:

1. Tests: Add a test file ```pysmt/test/test_<theory>.py```, to
demonstrate the use for the theory (e.g., ```pysmt/test/test_bv.py```).

2. Operators: Add the (basic) operators in ```pysmt/operators.py```,
create a constant for each operator, and extend the relevant
structures.

3. Typing: Extend ```pysmt/typing.py``` to include the types (sorts)
of the new theory.

4. Walker: Extend ```pysmt/walkers/generic.py``` to include one
```walk_``` function for each of the basic operators.

5. FNode: Extend ```is_*``` methods in
```pysmt/fnode.py:FNode```. This makes it possible to check the type
of an expression, obtaining additional elements (e.g., width of a
bitvector constant).

5. Typechecker: Extend ```pysmt/type_checker.py:SimpleTypeChecker```
to include type-checking rules.

6. FormulaManager: Create constructor for all operators, including
syntactic sugar, in ```pysmt/formula.py:FormulaManager```

At this point you are able to build expressions in the new
theory. This is a good time to start running your tests.

8. Printers: Extend ```pysmt/printers.py:HRPrinter``` to be able to
print expressions in the new theory (you might need to do this
earlier, if you need to debug your tests output).

7. Examples: Extend ```pysmt/test/examples.py``` with at least one
example formula for each new operator defined in FormulaManager. These
examples are used in many tests, and will help you identify parts of
the system that still need to be extended (e.g., Simplifier).

8. Theories and Logics: Extend ```pysmt/logics.py``` to include the
new Theory and possible logics that derive from this Theory. In
particular, define logics for each theory combination that makes
sense.

9. SMT-LIB: Extend ```pysmt/smtlib/parser.py:SmtLibParser``` and
```pysmt/smtlib/printers.py``` to support the new
operators.

10. Shortcuts: All methods that were added in FormulaManager need to
be available in ```pysmt/shortcuts.py```.


At this point all pySMT tests should pass. This might require
extending other walkers to support the new operators.

10. Solver: Extend at least one solver to support the Logic. This is
done by extending the associated Converter (e.g.,
```pysmt/solvers/msat.py:MSatConverter```) and adding at least one
logic to its ```LOGICS``` field. As a bare-minimum, this will require
a way of converting solvers-constants back into pySMT constants
(```Converter.back()```).
